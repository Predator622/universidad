### Procedimiento Almacenado para Actualización de Inventario

```sql
CREATE OR REPLACE PROCEDURE actualizar_inventario(p_codigo_producto INT, p_cantidad_nueva INT) 
AS $$
BEGIN
    -- Transacción para asegurar la integridad de los datos
    BEGIN
        UPDATE inventario SET cantidad = p_cantidad_nueva WHERE codigo_producto = p_codigo_producto;
        
        IF NOT FOUND THEN
            RAISE EXCEPTION 'Producto no encontrado en el inventario.';
        END IF;

        COMMIT;
    EXCEPTION 
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END;
END;
$$ LANGUAGE plpgsql;
```

### Procedimiento Almacenado para Insertar Detalle de Pedido

```sql
CREATE OR REPLACE PROCEDURE insertar_detalle_pedido(p_codigo_pedido INT, p_codigo_producto INT, p_cantidad INT) 
AS $$
DECLARE
    v_existencia INT;
BEGIN
    -- Verificar existencias antes de la inserción
    SELECT cantidad INTO v_existencia FROM inventario WHERE codigo_producto = p_codigo_producto;

    IF v_existencia < p_cantidad THEN
        RAISE EXCEPTION 'No hay suficiente stock para completar el pedido.';
    END IF;

    INSERT INTO detallepedido (codigo_pedido, codigo_producto, cantidad) VALUES (p_codigo_pedido, p_codigo_producto, p_cantidad);

    -- Actualizar inventario después de la inserción
    UPDATE inventario SET cantidad = cantidad - p_cantidad WHERE codigo_producto = p_codigo_producto;
END;
$$ LANGUAGE plpgsql;
```

### Función para Devolver Gama de Productos Más Vendidos

```sql
CREATE OR REPLACE FUNCTION gama_mas_vendida() 
RETURNS TABLE (codigo_gama INT, nombre_gama VARCHAR(100), cantidad_total INT) AS $$
BEGIN
    RETURN QUERY
    WITH ventas_por_producto AS (
        SELECT dp.codigo_producto, SUM(dp.cantidad) as total_ventas FROM detallepedido dp GROUP BY dp.codigo_producto
    ),
    productos_con_gama AS (
        SELECT p.codigo_producto, g.codigo_gama, g.nombre_gama FROM producto p JOIN gammaproducto g ON p.codigo_gama = g.codigo_gama
    )
    SELECT pg.codigo_gama, pg.nombre_gama, SUM(vp.total_ventas) as cantidad_total 
    FROM ventas_por_producto vp JOIN productos_con_gama pg ON vp.codigo_producto = pg.codigo_producto 
    GROUP BY pg.codigo_gama, pg.nombre_gama 
    ORDER BY cantidad_total DESC;
END;
$$ LANGUAGE plpgsql;
```

### Procedimiento Almacenado para Registro de Medios de Pago

```sql
CREATE OR REPLACE PROCEDURE registrar_medio_pago(p_codigo_cliente INT, p_tipo_pago VARCHAR(50)) 
AS $$
BEGIN
    -- Verificar existencia del cliente antes de la inserción
    IF NOT EXISTS (SELECT 1 FROM clientes WHERE codigo = p_codigo_cliente) THEN
        RAISE EXCEPTION 'El código de cliente no existe.';
    END IF;

    INSERT INTO mediosdepago (codigo_cliente, tipo_pago) VALUES (p_codigo_cliente, p_tipo_pago);
END;
$$ LANGUAGE plpgsql;
```

### Disparador para Descontar Existencias al Realizar Pedidos

```sql
CREATE OR REPLACE FUNCTION descontar_existencias() 
RETURNS TRIGGER AS $$
BEGIN
    -- Actualizar inventario después de la inserción en detallepedido
    UPDATE inventario SET cantidad = cantidad - NEW.cantidad WHERE codigo_producto = NEW.codigo_producto;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER actualizar_inventario AFTER INSERT ON detallepedido 
FOR EACH ROW EXECUTE FUNCTION descontar_existencias();
```

### Disparador para Evitar que un Empleado sea Su Propio Jefe

```sql
CREATE OR REPLACE FUNCTION evitar_jefe_propio() 
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.codigo_jefe = NEW.codigo_empleado THEN
        RAISE EXCEPTION 'Un empleado no puede ser su propio jefe.';
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER verificar_jefe BEFORE INSERT OR UPDATE ON empleados 
FOR EACH ROW EXECUTE FUNCTION evitar_jefe_propio();
```

### Disparador para Auditoría en Tablas Clientes y Pedidos

```sql
CREATE TABLE auditoria (
    id SERIAL PRIMARY KEY,
    tabla VARCHAR(50),
    accion VARCHAR(10),
    usuario VARCHAR(100),
    fecha TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    datos JSONB
);

CREATE OR REPLACE FUNCTION registrar_auditoria() 
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO auditoria (tabla, accion, usuario, datos) VALUES (
        TG_TABLE_NAME,
        CASE WHEN TG_OP = 'INSERT' THEN 'I'
             WHEN TG_OP = 'UPDATE' THEN 'U'
             WHEN TG_OP = 'DELETE' THEN 'D' END,
        current_user,
        jsonb_build_object(
            'old', COALESCE(OLD, NULL),
            'new', NEW
        )
    );

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER auditoria_clientes AFTER INSERT OR UPDATE OR DELETE ON clientes 
FOR EACH ROW EXECUTE FUNCTION registrar_auditoria();

CREATE TRIGGER auditoria_pedidos AFTER INSERT OR UPDATE OR DELETE ON pedidos 
FOR EACH ROW EXECUTE FUNCTION registrar_auditoria();
```

### Procedimiento Almacenado para Actualizar Valor Total de Pedido

```sql
CREATE OR REPLACE PROCEDURE actualizar_valor_total_pedido(p_codigo_pedido INT) 
AS $$
DECLARE
    v_valortotal NUMERIC;
BEGIN
    -- Calcular el valor total del pedido basado en detallepedido
    WITH valor_detalle AS (
        SELECT dp.codigo_producto, p.precio_venta * dp.cantidad as subtotal FROM detallepedido dp JOIN producto p ON dp.codigo_producto = p.codigo_producto WHERE dp.codigo_pedido = p_codigo_pedido
    )
    SELECT SUM(subtotal) INTO v_valortotal FROM valor_detalle;

    -- Actualizar el valor total en la tabla pedidos
    UPDATE pedidos SET valortotal = v_valortotal WHERE codigo = p_codigo_pedido;
END;
$$ LANGUAGE plpgsql;
```

### Disparador para Calcular Valor Total de Pedido Automáticamente

```sql
CREATE OR REPLACE FUNCTION calcular_valor_total_pedido() 
RETURNS TRIGGER AS $$
DECLARE
    v_valortotal NUMERIC;
BEGIN
    -- Calcular el valor total del pedido basado en detallepedido
    WITH valor_detalle AS (
        SELECT dp.codigo_producto, p.precio_venta * dp.cantidad as subtotal FROM detallepedido dp JOIN producto p ON dp.codigo_producto = p.codigo_producto WHERE dp.codigo_pedido = NEW.codigo_pedido
    )
    SELECT SUM(subtotal) INTO v_valortotal FROM valor_detalle;

    -- Actualizar el valor total en la tabla pedidos
    UPDATE pedidos SET valortotal = v_valortotal WHERE codigo = NEW.codigo_pedido;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER actualizar_valor_total AFTER INSERT OR DELETE ON detallepedido 
FOR EACH ROW EXECUTE FUNCTION calcular_valor_total_pedido();
```

### Disparador para Verificar Precio de Venta

```sql
CREATE OR REPLACE FUNCTION verificar_precio_venta() 
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.precio_venta <= (SELECT precio_proveedor * 1.1 FROM producto WHERE codigo = NEW.codigo_producto) THEN
        RAISE EXCEPTION 'El precio de venta debe ser superior al 10% del precio del proveedor.';
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER verificar_precio BEFORE INSERT OR UPDATE ON producto 
FOR EACH ROW EXECUTE FUNCTION verificar_precio_venta();
```

### Disparador para Verificar Inventario

```sql
CREATE OR REPLACE FUNCTION verificar_inventario() 
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.cantidad > (SELECT cantidad FROM inventario WHERE codigo_producto = NEW.codigo_producto) THEN
        RAISE EXCEPTION 'No hay suficiente stock en el inventario.';
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER verificar_stock BEFORE INSERT OR UPDATE ON detallepedido 
FOR EACH ROW EXECUTE FUNCTION verificar_inventario();
```