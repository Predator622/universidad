### Análisis Inicial

#### Respuestas a las preguntas:

1. **test_factorial_cxx**: Programa que calcula el factorial de un número usando métodos iterativo y recursivo, mide tiempos de ejecución.

2. **test_sort_cxx**: Programas para probar algoritmos de ordenamiento (bubble sort, quicksort, heapsort) en diferentes configuraciones de datos.

3. **comandos_txt**: Archivo con secuencias de comandos para compilar y ejecutar programas, generar tablas de resultados y gráficas.

4. **factorial_table_txt**: Tabla que contiene los tiempos de ejecución del factorial iterativo y recursivo para diferentes valores de entrada.

5. **sort_random_table_txt**, **sort_inverse_table_txt**, **sort_sorted_table_txt**: Tablas con tiempos de ejecución de algoritmos de ordenamiento en configuraciones aleatorias, inversas y ordenadas respectivamente.

#### Comandos Analizados:

- `make`: Compila los programas.
- `./my_test_factorial numero`: Ejecuta el programa factorial para un número dado.
- `./my_test_sort_random tamano_arreglo`: Ejecuta el programa de prueba de sort en configuración aleatoria.
- `gnuplot script.gp`: Genera gráficas a partir de datos.

### Factorial

#### Análisis Empírico:

1. **Gráfica**: La gráfica muestra que el algoritmo iterativo es más eficiente, especialmente para valores grandes del número factorial.

2. **Complejidad Teórica**:
   - Recursivo: O(n)
   - Iterativo: O(n)

3. **Límite Superior**:
   - El límite superior se alcanza cuando el valor de retorno supera la capacidad de representación de `long long int`. Se puede usar `unsigned long long` para ampliar este rango.

### Sort

#### Análisis Empírico:

1. **Gráficas**: Quicksort es más eficiente en configuraciones aleatorias y inversas, mientras que heapsort se comporta mejor en datos ya ordenados.

2. **Complejidad Teórica**:
   - Bubble sort: O(n^2)
   - Quicksort: O(n log n) promedio
   - Heapsort: O(n log n)

3. **Relación Complejidad Empírica vs Teórica**: Los resultados empíricos confirman la complejidad teórica, mostrando que quicksort es el más eficiente en general, seguido por heapsort y bubble sort.

### Código Ejemplo (C++17)

```cpp
#include <iostream>
#include <chrono>

// Iterative factorial function
unsigned long long factorial_iter(unsigned int n) {
    unsigned long long result = 1;
    for (auto i = 2u; i <= n; ++i)
        result *= i;
    return result;
}

// Recursive factorial function
unsigned long long factorial_rec(unsigned int n) {
    if(n == 0 || n == 1)
        return 1;
    else
        return n * factorial_rec(n - 1);
}

int main(int argc, char* argv[]) {
    unsigned int number = std::stoi(argv[1]);
    
    auto start_iter = std::chrono::high_resolution_clock::now();
    unsigned long long fact_iter = factorial_iter(number);
    auto end_iter = std::chrono::high_resolution_clock::now();

    auto start_rec = std::chrono::high_resolution_clock::now();
    unsigned long long fact_rec = factorial_rec(number);
    auto end_rec = std::chrono::high_resolution_clock::now();

    std::cout << number << " "
              << fact_iter << " "
              << fact_rec << " "
              << std::chrono::duration_cast<std::chrono::nanoseconds>(end_iter - start_iter).count() << " "
              << std::chrono::duration_cast<std::chrono::nanoseconds>(end_rec - start_rec).count();

    return 0;
}
```

### Comentarios Técnicos

```cpp
/**
 * @brief Función iterativa para calcular el factorial de un número.
 *
 * @param n Número entero no negativo.
 * @return unsigned long long Factorial del número dado.
 */
unsigned long long factorial_iter(unsigned int n);

/**
 * @brief Función recursiva para calcular el factorial de un número.
 *
 * @param n Número entero no negativo.
 * @return unsigned long long Factorial del número dado.
 */
unsigned long long factorial_rec(unsigned int n);
```