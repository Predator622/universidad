### Procedimientos Almacenados

#### Actualización de Inventario de Producto
```sql
CREATE OR REPLACE PROCEDURE actualizar_inventario_producto(
    p_codigo_producto INT,
    p_cantidad_nueva INT
)
LANGUAGE plpgsql AS $$
BEGIN
    -- Transacción para asegurar la integridad del inventario
    BEGIN
        UPDATE productos SET cantidad = p_cantidad_nueva WHERE codigo_producto = p_codigo_producto;
        
        IF NOT FOUND THEN
            RAISE EXCEPTION 'Producto no encontrado';
        END IF;

        COMMIT;
    EXCEPTION WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END;
$$;
```

#### Insertar Información del Detalle de Pedido
```sql
CREATE OR REPLACE PROCEDURE insertar_detalle_pedido(
    p_codigo_pedido INT,
    p_codigo_producto INT,
    p_cantidad INT,
    p_precio_unitario DECIMAL(10,2)
)
LANGUAGE plpgsql AS $$
BEGIN
    -- Transacción para asegurar la integridad del detalle de pedido
    BEGIN
        INSERT INTO detallepedido (codigo_pedido, codigo_producto, cantidad, precio_unitario) 
        VALUES (p_codigo_pedido, p_codigo_producto, p_cantidad, p_precio_unitario);

        COMMIT;
    EXCEPTION WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END;
$$;
```

### Funciones

#### Gama de Productos Más Vendidos
```sql
CREATE OR REPLACE FUNCTION gama_productos_mas_vendidos()
RETURNS TABLE (gama VARCHAR(100), total_pedidos INT) AS $$
BEGIN
    RETURN QUERY 
        WITH ventas_por_producto AS (
            SELECT p.codigo_producto, COUNT(dp.codigo_pedido) as cantidad_ventas
            FROM productos p JOIN detallepedido dp ON p.codigo_producto = dp.codigo_producto
            GROUP BY p.codigo_producto
        )
        SELECT g.descripcion_gama, SUM(v.cantidad_ventas)
        FROM ventas_por_producto v JOIN gamas_productos g ON v.codigo_producto IN (SELECT codigo_producto FROM productos WHERE gama_id = g.id_gama)
        GROUP BY g.descripcion_gama;
END;
$$ LANGUAGE plpgsql;
```

### Disparadores

#### Descontar Existencias de Productos al Realizar Pedido
```sql
CREATE OR REPLACE FUNCTION descontar_existencias_pedido() RETURNS TRIGGER AS $$
BEGIN
    -- Transacción para asegurar la integridad del inventario
    BEGIN
        UPDATE productos SET cantidad = cantidad - NEW.cantidad WHERE codigo_producto = NEW.codigo_producto;

        IF NOT FOUND THEN
            RAISE EXCEPTION 'Producto no encontrado';
        END IF;
        
        COMMIT;
    EXCEPTION WHEN OTHERS THEN
        ROLLBACK;
        RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER descontar_existencias AFTER INSERT ON detallepedido FOR EACH ROW EXECUTE FUNCTION descontar_existencias_pedido();
```

#### Evitar que un Empleado Sea Su Propio Jefe
```sql
CREATE OR REPLACE FUNCTION evitar_empleado_jefe() RETURNS TRIGGER AS $$
BEGIN
    IF NEW.codigo_jefe = NEW.codigo_empleado THEN
        RAISE EXCEPTION 'Un empleado no puede ser su propio jefe';
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE CONSTRAINT TRIGGER verificar_jefe BEFORE INSERT OR UPDATE ON empleados FOR EACH ROW EXECUTE FUNCTION evitar_empleado_jefe();
```

### Automatización de la Base de Datos

#### Actualizar Valor Total del Pedido
```sql
CREATE OR REPLACE PROCEDURE actualizar_valor_total_pedido(p_codigo_pedido INT) AS $$
DECLARE
    v_valortotal DECIMAL(10,2);
BEGIN
    -- Transacción para asegurar la integridad del valor total
    BEGIN
        SELECT SUM(dp.cantidad * dp.precio_unitario) INTO v_valortotal 
        FROM detallepedido dp WHERE dp.codigo_pedido = p_codigo_pedido;

        UPDATE pedidos SET valortotal = v_valortotal WHERE codigo_pedido = p_codigo_pedido;
        
        COMMIT;
    EXCEPTION WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END;
$$ LANGUAGE plpgsql;
```

#### Actualizar Valor Total de Todos los Pedidos
```sql
CREATE OR REPLACE PROCEDURE actualizar_valor_total_todos_pedidos() AS $$
BEGIN
    -- Transacción para asegurar la integridad del valor total
    BEGIN
        UPDATE pedidos SET valortotal = (SELECT SUM(dp.cantidad * dp.precio_unitario) 
                                         FROM detallepedido dp WHERE dp.codigo_pedido = pedidos.codigo_pedido);
        
        COMMIT;
    EXCEPTION WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END;
$$ LANGUAGE plpgsql;
```

#### Disparador para Registar Valor Total de Pedido Automáticamente
```sql
CREATE OR REPLACE FUNCTION actualizar_valortotal_detallepedido() RETURNS TRIGGER AS $$
BEGIN
    -- Transacción para asegurar la integridad del valor total
    BEGIN
        PERFORM actualizar_valor_total_pedido(NEW.codigo_pedido);
        
        COMMIT;
    EXCEPTION WHEN OTHERS THEN
        ROLLBACK;
        RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER actualizar_valortotal AFTER INSERT OR UPDATE ON detallepedido FOR EACH ROW EXECUTE FUNCTION actualizar_valortotal_detallepedido();
```

### Controles Adicionales

#### Verificar Precio de Venta Superior al 10% del Precio Proveedor
```sql
CREATE OR REPLACE FUNCTION verificar_precio_venta() RETURNS TRIGGER AS $$
BEGIN
    IF NEW.precio_venta <= (SELECT precio_proveedor * 1.1 FROM productos WHERE codigo_producto = NEW.codigo_producto) THEN
        RAISE EXCEPTION 'El precio de venta debe ser superior al 10% del precio proveedor';
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER verificar_precio_venta BEFORE INSERT OR UPDATE ON productos FOR EACH ROW EXECUTE FUNCTION verificar_precio_venta();
```

#### Verificar Inventario No Quede Vacío
```sql
CREATE OR REPLACE FUNCTION evitar_inventario_vacio() RETURNS TRIGGER AS $$
BEGIN
    IF NEW.cantidad < 0 THEN
        RAISE EXCEPTION 'La cantidad no puede ser negativa, el inventario quedaría vacío';
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER evitar_inventario_vacio BEFORE INSERT OR UPDATE ON productos FOR EACH ROW EXECUTE FUNCTION evitar_inventario_vacio();
```

### Auditoría de Tablas

#### Procesos de Inserción, Actualización y Borrado
```sql
CREATE TABLE auditoria_clientes (
    id SERIAL PRIMARY KEY,
    accion VARCHAR(10),
    usuario VARCHAR(50),
    fecha TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    datos JSONB
);

CREATE OR REPLACE FUNCTION registrar_auditoria_cliente() RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO auditoria_clientes (accion, usuario, datos) VALUES 
        (TG_OP::text, current_user, jsonb_build_object('codigo_cliente', OLD.codigo_cliente, 'nombre', OLD.nombre, 'direccion', OLD.direccion));
    
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER registrar_auditoria BEFORE INSERT OR UPDATE OR DELETE ON clientes FOR EACH ROW EXECUTE FUNCTION registrar_auditoria_cliente();
```